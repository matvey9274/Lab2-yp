#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

using namespace std;

void show(int **A, int N);	// подпрограмма вывода поля в консоль
void next(int **A, int N);

int main()
{
	// вводим размер поля
	int N;
	cout << "N = ";
	cin >> N;
	system("cls"); // очищаем консоль

	srand(time(0)); // запускаем генератор случайных чисел

	// выделяем память под поле
	int **A;
	A = new int*[N]; // N строчек
	for(int i=0; i<N; i++)
		A[i] = new int[N]; // N столбцов

	
	for(int i=0; i<N; i++) // проходим по всем строка поля
		for(int j=0; j<N; j++) // проходим по всем столбцам поля
			A[i][j] = rand()%2; // заполняем случайным образом: 1 - живая клетка, 0 - мертвая

	show(A,N); // вывести поле в консоль
	Sleep(1500); // сделать паузу 1500 миллисекунд

	while(true){ // повторять бесконечное число раз, пока программа не закроется
		system("cls"); // очистить консоль
		show(A,N); // вывести поле в консоль
		next(A,N); // обновить поле: рассчитать новое поколение клеток
		Sleep(200); // сделать паузу 200 миллисекунд
	}

	return 0;
}

void show(int **A, int N){	// подпрограмма вывода поля в консоль
	for(int i=0; i<N; i++){
		for(int j=0; j<N; j++) // выводим строку в цикле
			if(A[i][j]==0) cout << ' '; // если клетка мертвая вывести пробел
			else cout << 'o'; // иначе вывести кружочек
		cout << endl; // переносим строку
	}
}

void next(int **A, int N){ // подпрограмма расчета следующего поколения клеток
	// создаем новое поле для нового поколения
	int **B;
	B = new int*[N];
	for(int i=0; i<N; i++)
		B[i] = new int[N];

	// проверяем каждую клетку на старом поле
	for(int i=0; i<N; i++){
		for(int j=0; j<N; j++){
			int ip = i-1; if (ip<0) ip = N-1; // находим индекс левых элементов
			int in = i+1; if (in>=N) in = 0; // находим индекс правых элементов
			int jp = j-1; if (jp<0) jp = N-1; // находим индекс верхних элементов
			int jn = j+1; if (jn>=N) jn = 0; // находим индекс нижних элементов
			// считаем живых соседей
			int s = A[ip][jp] + A[ip][j] + A[ip][jn] + A[i][jp] + A[i][jn] + A[in][jp] + A[in][j] + A[in][jn];
			if( (A[i][j]==1) && (s>=2) && (s<=3)) // если клетка живая и живы 2-3 соседа
				B[i][j] = 1; // клетка продолжает жить
			else if((A[i][j]==0) && (s==3)) // если клетка мертвая и живы ровно 2 соседа
				B[i][j] = 1; // клетка оживает
			else B[i][j] = 0; // иначе клетка будет мертвой
		}
	}
	
	// копируем новое поле в старое
	for(int i=0; i<N; i++){
		for(int j=0; j<N; j++){
			A[i][j] = B[i][j];
		}
	}

	// удаляем новое поле
	for(int i=0; i<N; i++)
		delete [] B[i];
	delete [] B;
}