#include <iostream>
#include <stdlib.h>
#include <time.h>
#include <math.h>

using namespace std;

void matrix3(double **A, int n); // подпрограмма, создающая матрицу 3x3 с ответом (-1, 3, 2)
void randomMatrix(double **A, int n); // подпрограмма, создающаю случайную матрицу
void matrix0(double **A, int n); // подпрограмма, создающая матрицу 3x3 с нулевой строкой
void GilbertMatrix(double **A, int n); // подпрограмма, создающая матрицу Гильберта

void printMatrix(double **A, int n); // подпрограмма, печатающая матрицу в консоль

void Gauss(double **A, double *x, int n); // метод Гаусса
double delta(double **A, double *x, int n); // подпрограмма нахождения погрешности

int main()
{
	setlocale(LC_ALL,"Russian" );
	
	int n; // размер матрицы
	cout << "n = ";
	cin >> n;

	// Выделяем память под расширенную матрицу
	double **A = new double* [n];
	for(int i=0; i<n; i++)
		A[i] = new double[n+1];
	// Выделяем память под вектор переменных
	double *x = new double[n];

	cout << "Выберите тип матрицы: " << endl
		<< "1 - заданная явно 3х3 с ответом (-1, 3, 2)" << endl
		<< "2 - заданная случайным образом" << endl
		<< "3 - матрица 3х3 с нулевой строкой" << endl
		<< "4 - матрица Гильберта" << endl;

	int q;
	cin >> q;
	// в зависимости от введенного числа выбираем разные матрицы
	switch(q){
		case 1:{
			matrix3(A,n); // создается матрица заданная явно 3х3 с ответом (-1, 3, 2)
			printMatrix(A,n); // выводим матрицу в консоль
			Gauss(A,x,n); // решаем систему
			break;
		}
		case 2:{
			randomMatrix(A,n); // создается матрица заданная случайным образом
			time_t t1 = clock(); // засекаем время начала решения
			Gauss(A,x,n); // решаем систему
			time_t t2 = clock();	// засекаем время конца решения
			cout << "Время решения: " << (t2 - t1)/(CLOCKS_PER_SEC / 1000.0) << " миллисекунд" << endl; // печатаем время решения
			break;
		}
		case 3:{
			matrix0(A,n);  // создается матрица 3х3 с нулевой строкой
			printMatrix(A,n); // выводим матрицу в консоль
			Gauss(A,x,n); // решаем систему
			break;
		}
		case 4:{
			GilbertMatrix(A,n); // создается матрица  Гильберта
			Gauss(A,x,n); // решаем систему
			break;
		}
	}
	
	// выводим решение и  погрешность
	if(q!=3){ // если матрица не является неопределенной
		cout << "Решение = (";
		for(int i=0; i<n; i++)
			cout << x[i] << "; ";
		cout << ")" << endl;
		cout << "Погрешность = " << delta(A,x,n);
	}

	// Освобождаем память
	delete [] x;
	for(int i=0; i<n; i++)
		delete [] A[i];
	delete [] A;
	return 0;
}

// подпрограмма, создающая матрицу 3x3 с ответом (-1, 3, 2)
void matrix3(double **A, int n) 
{
	if (n==3){
		A[0][0] = 3;
		A[0][1] = 2;
		A[0][2] = 1;
		A[0][3] = 5;
		A[1][0] = 1;
		A[1][1] = 1;
		A[1][2] = -1;
		A[1][3] = 0;
		A[2][0] = 4;
		A[2][1] = -1;
		A[2][2] = 5;
		A[2][3] = 3;
	}
	else
		cout << "Нужно указать n = 3" << endl;
}

// подпрограмма, создающаю случайную матрицу
void randomMatrix(double **A, int n)
{
	srand(time(0)); // запускаем генератор случайных чисел
	for(int i=0; i<n; i++) // проходим по строкам
		for(int j=0; j<n+1; j++) // проходим по элементам строки
			A[i][j] = rand()%101 - 50; // каждый элемент матрицы задаем случайным от -50 до 50
}

// подпрограмма, создающая матрицу 3x3 с нулевой строкой
void matrix0(double **A, int n)
{
	if (n==3){
		A[0][0] = 3;
		A[0][1] = 2;
		A[0][2] = 1;
		A[0][3] = 5;
		A[1][0] = 0;
		A[1][1] = 0;
		A[1][2] = 0;
		A[1][3] = 0;
		A[2][0] = 4;
		A[2][1] = -1;
		A[2][2] = 5;
		A[2][3] = 3;
	}
	else
		cout << "Нужно указать n = 3" << endl;
}

// подпрограмма, создающая матрицу Гильберта
void GilbertMatrix(double **A, int n)
{
	for(int i=0; i<n; i++) // проходим по строкам
		for(int j=0; j<n+1; j++) // проходим по элементам строки
			A[i][j] = 1.0/(i+j+1); // каждый элемент матрицы задаем по формуле Гильберта
}

// подпрограмма, печатающая матрицу в консоль
void printMatrix(double **A, int n)
{
	for(int i=0; i<n; i++){ // проходим по строкам
		for(int j=0; j<n; j++) // проходим по элементам строки
			cout << A[i][j] << " "; // выводим элемент матрицы через пробел
		cout << "| " << A[i][n] << endl; // выводим разделитель и число из правой части
	}
}

// метод Гаусса
void Gauss(double **A, double *x, int n)
{
	// прямой ход метода: выбираем очередную строку и рассматривам
	// матрицу меньшего порядка с верхним левым элементом A[i][i]
	for(int i=0; i<n; i++){
		// выбираем главный элемент по строке
		double m = A[i][i]; // если не найдется элемента больше, главным будет первый != 0
		int jm = i; // номер столбца, в котром найден главный элемент
		for(int j=i; j<n; j++)
			if(A[i][j]>m){ // если в строке нашелся элемент больше
				m = A[i][j]; // перезаписываем максимум
				jm = j; // записываем номер столбца, в котором он нашелся
			}

		// первый столбец меняем местами со столбцом, содержащим главный элемент
		for(int k=0; k<n; k++){
			double t = A[k][i];
			A[k][i] = A[k][jm];
			A[k][jm] = t;
		}

		if(m==0){ // если все элементы строки равны 0
			cout << "Матрица не определена, единственного решения нет" << endl;
			return; // завершаем процесс, т.к. x найден не будет
		}

		// делим все элементы текущей строки на главный элемент
		for(int j=i; j<n+1; j++)
			A[i][j] = A[i][j] / m;
		// получаем 0 в начале всех последующих строк:
		// отнимаем от k-й строки текущую строку, умноженную на первый элемент k-й строки
		for(int k=i+1; k<n; k++){
			double t = A[k][i]; // сохраняем первый элемент k-й строки
			for(int j=i; j<n+1; j++){
				A[k][j] = A[k][j] - A[i][j]*t;
			}
		}
	}
	// прямой ход завершен
	// начинаем обратный ход с нижней строки
	for(int i=n-1; i>=0; i--){
		double t = A[i][n]; // изначально берем правую часть
		for(int j=i+1; j<n; j++)
			t = t - A[i][j]*x[j]; // поочередно переносим в правую часть произведение уже найденных переменных и их коэффициентов из матрицы
		x[i] = t;
	}
}

double delta(double **A, double *x, int n){
	// выделяем память для вектора правой части
	double *B1 = new double[n];
	double d = 0.0; // если не найдется погрешность больше, она будет равна нулю

	// вычисляем вектор правой части: умножаем матрицу A на вектор х
	for(int i=0; i<n; i++){
		B1[i] = 0.0;
		for(int j=0; j<n; j++)
			B1[i] += A[i][j]*x[j];
	}

	// ищем наибольшую разность между данной и вычисленной правыми частями
	for(int i=0; i<n; i++) // проходим по каждой строчке правой части
		if(fabs(B1[i]-A[i][n]) > d) // если модуль разности больше найденного
			d = fabs(B1[i]-A[i][n]); // записываем новый

	// очищаем память
	delete [] B1;
	// возвращаем результат в главную программу
	return d;
}